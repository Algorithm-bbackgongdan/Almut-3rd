# week1

## 21758
결과 : solve
시도 횟수 : 6~7번?

1. 문제 조건을 제대로 읽지 않음. "만일 전부 다 녹을 때까지 두 덩어리 이상으로 분리되지 않으면 프로그램은 0을 출력한다."
2. max recursion error. dfs 로 구현했다가 bfs 로 변경하니 잘 돌아감.

해결 방법 :
- 입력 받기
- 인접한 바다의 개수를 구하기
- 해당 개수만큼 얼음 녹이기, max() 함수를 이용해 얼음이 음수가 될 경우 0으로 변경
- bfs 로 연결된 얼음의 개수 구하기 -> 얼음이 2개 보다 많을 경우 종료, 전부 다 없는 경우는 flag 변수로 체크해서 종료

느낀 점:
솔루션을 떠올리기는 쉬운 문제였으나, 정답까지 가는 데에는 어려운 문제였다. 
구현 문제는 문제를 잘 읽고, 설계를 미리 하고 가는 것이 중요함을 느낌.
그리고 웬만하면 dfs 말고 bfs 로 풀어야 겠다.

## 두 용액
기존에 풀었던 문제였다.
처음부터 이진 탐색 아이디어를 떠올렸고, 예전에 풀었던 방식도 이와 동일하게 풀이했던 걸 보고
역시 사람은 변하지 않는구나 라는.. 깨달음을 얻을 수 있었던 문제였다.
무난한 문제였다.

## programers
결과 : solve
시도 횟수 : 1

1. 최단경로 문제와 동일하게 풀이할 수 있겠다고 힌트를 얻었다.
2. 다시 원래 체크했던 단어로 돌아가는 경우는 solution 이 될 수 없다고 판단해서 리스트에서 제거하는 방식으로 시간복잡도를 감소시켰다.
3. bfs 로 구현하였기 때문에 최단 경로가 구해지면 바로 break 하고 정답을 출력하게 된다.