# 성격 유형 검사하기
조건에 따라 연산한 후 값을 출력하면 되는 단순한 문제이다.

# 코딩 테스트 공부
결과 : fail
Test case 에 대해서는 전부 정답이지만, 제출 시 전체 TC 중 1개만 맞음.

---

주어진 모든 문제를 풀 수 있는 알고력과 코딩력을 가진다는 말은, 주어진 problems 배열에서 가장 높은 req_alp와 req_cop을 각각 알고력과 코딩력으로 가지는 것과 동일합니다.
따라서, 해결해야 하는 문제는 (초기 알고력, 초기 코딩력) 상태에서 시작해 (목표 알고력, 목표 코딩력) 상태에 도달하는 최단 시간을 구하는 문제입니다.

이 말에서 힌트를 얻었다. 예를 들어, 최대 달성해야 하는 코딩력이 10일 경우에, 만약 더 빠른 시간에 12를 달성할 수 있다면 리턴해야 하는 시간은 12를 달성할 때의 값일 것이다.
따라서, 단순히 dp 배열을 만든 후 정확한 `dp[i][j]` 인덱스의 값을 리턴하기 보다, 해당 문제를 풀 수 있으면서,
더 빠른 시간 안에 달성할 수 있는 시간이 있다면 해당 시간을 리턴해야 하는 것이다.

---

도달해야 하는 목표 알고력과 코딩력이 처음 초기값보다 작은 경우가 있다.
이러한 경우를 핸들링하기 위한 코드를 작성해야 100%로 통과할 수 있다.


# 등산 코스 정하기
dijkstra 로 접근하였다.
intensity 라는 개념을 새로 추가하였지만,
결국 "최단 경로 중 가장 긴 거리" 이기 때문에,
dijkstra 알고리즘에서 distance 를 업데이트하는 로직과 동일하게
업데이트 해 나가면 풀 수 있다.

주의해야 할 점은 처음에 summits, gates 를 set 으로 중복값을 없애고 시작해야 시간 초과를 피할 수 있다.
솔직히 이건 보장해 주어야 하는 것 아닌가??


# 총평
edge 케이스에 대해 잘 생각하지 못해서 시간을 많이 소요하게 된다.
특이한 케이스나, 일반적이지 않은 경우를 생각해야 하는 이런 식의 문제를 좋아하는 것 같다.