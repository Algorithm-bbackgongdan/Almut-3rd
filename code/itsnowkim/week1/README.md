# week1

## 21758
결과 : 55점 마무리

- 첫 시도
처음 시도한 알고리즘은 다음과 같다.
맨 왼쪽 or 맨 오른쪽에 꿀벌과 꿀통을 놓는다.
더 작은 수가 꿀벌이 있을 위치, 같을 경우 상관 없음. 
이 때, 이 꿀벌은 전체 원소 - 본인이 위치한 원소 만큼 수확함.
다른 벌은 나머지 칸 중 한 칸에 위치하는데, for loop 돌면서 가장 좋은 output 을 가질 수 있는 칸 위에 위치하게 된다. O(N-2)
O(N)

그러나, 위의 경우에서는 예제3 과 같이 꿀통이 가운데 있어야 하는 경우를 체크하지 못하므로, 꿀통이 가운데에 있는 경우인 sol2 함수를 작성하였다.

- 두 번째 시도
https://www.acmicpc.net/board/view/90474
반례 : 어느 한 쪽이 크다고 무조건 그 방향으로 두 마리를 모두 날리는 것이 최적이 되지는 않습니다.
다음과 같이 왼쪽 끝이 오른쪽 끝보다 꿀이 적지만, 왼쪽 끝 바로 앞에 조금이나마 더 많은 꿀이 있는 경우를 놓칠 수 있습니다

입력
7
10 5 4 3 2 1 11

올바른 출력
48
//꿀통을 10에, 두 벌을 각각 1과 11에 놓으면 됩니다.

이 코드의 출력
42

위와 같은 반례를 생각하지 못했고, 위의 반례를 보고 코드를 수정하여 벌을 날리는 방향 두 가지 모두 고려하여 코드를 작성하여 제출하였다.

하지만 55 점으로 마무리하게 되었다. 아마 중복된 계산을 줄여야 높은 점수를 받을 수 있는 것으로 예상된다.
